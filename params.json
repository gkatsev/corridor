{"name":"corridor","tagline":"{json} → <html> → {json}","body":"# corridor\r\n\r\n**{json} &rarr; &lt;html&gt; &rarr; {json}**\r\n\r\nBi-directional data binding without the fuss.\r\n\r\n## why you need corridor\r\n\r\nYour data is in JSON, but your users interact with HTML.\r\ncorridor's shuttles your data between your JSON and your HTML.\r\n\r\nIn a nutshell, corridor lets you turn this:\r\n\r\n```html\r\n<fieldset name=\"project\">\r\n  <input type=\"text\" name=\"dependencies.foo\" value=\"~0.1.0\" />\r\n  <input type=\"text\" name=\"dependencies.bar\" value=\"~2.1.0\" />\r\n</fieldset>\r\n```\r\n\r\nInto this:\r\n\r\n```js\r\n{\r\n  \"project\": {\r\n    \"dependencies\": {\r\n      \"foo\": \"~0.1.0\",\r\n      \"bar\": \"~2.1.0\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAnd vice versa.\r\n\r\n### how corridor works\r\n\r\ncorridor is a runtime library, not a templating language.\r\nIt runs in the browser, easily transferring your data both ways: from form fields to JSON and (importantly) back again.\r\n\r\ncorridor uses the `name` attributes of your HTML elements to determine how a given input contributes to a JSON representation.\r\nIn most cases it'll just work, but if you need more flexibility, corridor's API options offer many points of customization.\r\n\r\nRead the tutorial to get started, or skip to the API section for the details.\r\n\r\n### corridor's philosophy\r\n\r\nThe corridor project philosophy boils down to these points:\r\n\r\n * **intelligent** — it learns what to do by looking at the data on the ground.\r\n * **unobtrusive** — it's just one function, without dependencies or side-effects.\r\n * **clear** — corridor's code, tests, and issues are crisply documented.\r\n\r\nDevelopment of features, bugfixes and documentation are held to these ideals.\r\n\r\n## getting corridor\r\n\r\ncorridor is a single js file with no dependencies.\r\nYou can get it in either of two ways:\r\n\r\n* from github: grab [corridor.js](https://github.com/jimbojw/corridor/blob/master/src/corridor.js) out of the [corridor repo](https://github.com/jimbojw/corridor)\r\n* from npm: \r\n\r\n```sh\r\n$ npm install corridor\r\n```\r\n\r\n## corridor tutorial\r\n\r\nIt would be great if users could just edit JSON directly.\r\nThat way, your REST API would be all you'd need.\r\n\r\nBut unfortunately, your users interact with the Document Object Model (DOM) representation of your HTML.\r\nWhich means that it's your job to figure out how to get these two views of the data to match.\r\n\r\nThe corridor library has only one function called `corridor()`.\r\nThis function does one of two things:\r\n\r\n * extract data out of a DOM heirarchy (form elements), or\r\n * insert data into the DOM.\r\n\r\nLet's take a look at how this works by using the practical example of a [`package.json`](https://npmjs.org/doc/json.html) file.\r\nWe'll build out a single-page web app for manipulating a package.json file.\r\n\r\nTo skip to the outcome of this walkthrough, see the `example.html` file.\r\n\r\n### package.json example app\r\n\r\nFor a `package.json` file, you need at least the following data:\r\n\r\n * name - the name of the project.\r\n * version - the semantic version number of the project.\r\n\r\nAnd you may also want the following fields:\r\n\r\n * keywords - an array of keywords for npm to find your package.\r\n * dependencies - a collection of package/version pairs.\r\n\r\nIn all, that would produce JSON something like this (values omitted):\r\n\r\n```js\r\n{\r\n  \"name\": \"\",\r\n  \"version\": \"\",\r\n  \"keywords\": [],\r\n  \"dependencies\": {}\r\n}\r\n```\r\n\r\nNow let's put together the UI for working with this data.\r\n\r\n### corridor fields\r\n\r\nLet's start with the `name` field.\r\nHere's the HTML you'd need:\r\n\r\n```html\r\n<input type=\"text\" name=\"name\" />\r\n```\r\n\r\nLet's try it out.\r\nMake sure you have the `<input>` HTML on a page and the `corridor.js` library included.\r\nThen you can call the corridor function with no arguments to extract all the data on the page.\r\n\r\n```js\r\ncorridor(); // returns {\"name\":\"\"} (or whatever you've typed in the box).\r\n```\r\n\r\nThe first argument to corridor is the root element for the data extraction.\r\nIf you don't provide one, corridor will assume you meant to search down from the document root.\r\n\r\n### corridor data types\r\n\r\nBy default, corridor will automatically detect the type of the value for an element.\r\nBut you can override this behavior by providing a `data-type` attribute.\r\n\r\nLet's see how this applies to the `keywords` field of a package.json.\r\n\r\nThe HTML for the keywords field should look like this:\r\n\r\n```html\r\n<textarea name=\"keywords\" data-type=\"list\"></textarea>\r\n```\r\n\r\nHere the `data-type` indicates that we have a `list` value.\r\ncorridor will try to parse the text in the `<textarea>` as a list of items, and will output an array.\r\n\r\nLet's give it a try!\r\nWith the above `<textarea>` on a page, enter the text `\"abc, def\"` (no quotes).\r\nThen run corridor:\r\n\r\n```js\r\nJSON.stringify(corridor(), null, 2);\r\n// produces\r\n{\r\n  \"name\": \"\",\r\n  \"keywords\": [\r\n    \"abc\",\r\n    \"def\"\r\n  ]\r\n}\r\n```\r\n\r\nSupported data types include:\r\n\r\n * auto - default, automatically detects the type.\r\n * string - just treats value as a string.\r\n * boolean - always true or false.\r\n * number - parses string as a float.\r\n * list - parses value as a list.\r\n * json - treats value as valid JSON.\r\n\r\nIf you can't set `data-type` because your application already uses this attribute for something else, you can use `data-opts` instead.\r\nHere's how it would look with `data-opts`:\r\n\r\n```html\r\n<textarea name=\"keywords\" data-opts='{\"type\":\"list\"}'></textarea>\r\n```\r\n\r\nThe `data-opts` attribute, when present, must contain valid JSON.\r\nNote that options specified in `data-opts` will override `data-*` attributes.\r\n\r\nTake this input for example:\r\n\r\n```html\r\n<input type=\"text\" name=\"zip\" data-type=\"string\" data-opts='{\"type\":\"number\"}' />\r\n```\r\n\r\nIn this case, corridor will treat the zip as a number.\r\n\r\n### corridor field nesting\r\n\r\ncorridor will use parent elements' names to create nested structures.\r\n\r\nFor example, say we wanted to have drop-down choices for the `foo` and `bar` dependencies.\r\nThe corridor HTML for that would look something like this:\r\n\r\n```html\r\n<fieldset>\r\n  <label>\r\n    foo:\r\n    <select name=\"dependencies.foo\">\r\n      <option value=\"~1.1.0\">foo: version 1</option>\r\n      <option value=\"~2.0.0\">foo: version 2</option>\r\n    </select>\r\n  </label>\r\n  <label>\r\n    bar:\r\n    <select name=\"dependencies.bar\">\r\n      <option value=\"~3.5.0\">bar: version 3</option>\r\n      <option value=\"~4.1.0\">bar: version 4</option>\r\n    </select>\r\n  </label>\r\n</p>\r\n```\r\n\r\nRunning `corridor()` on this gives us:\r\n\r\n```js\r\n{\r\n  \"dependencies\": {\r\n    \"foo\": \"~1.1.0\",\r\n    \"bar\": \"~3.5.0\"\r\n  }\r\n}\r\n```\r\n\r\nBut it doesn't end there!\r\nSince both the `foo` and `bar` select boxes live under `dependencies`, giving a `name` to the fieldset would have the same effect:\r\n\r\n```html\r\n<fieldset name=\"dependencies\">\r\n  <label>\r\n    foo:\r\n    <select name=\"foo\">\r\n      <option value=\"~1.1.0\">foo: version 1</option>\r\n      <option value=\"~2.0.0\">foo: version 2</option>\r\n    </select>\r\n  </label>\r\n  <label>\r\n    bar:\r\n    <select name=\"bar\">\r\n      <option value=\"~3.5.0\">bar: version 3</option>\r\n      <option value=\"~4.1.0\">bar: version 4</option>\r\n    </select>\r\n  </label>\r\n</p>\r\n```\r\n\r\nIf you run corridor against this HTML, you'll get the same JSON listed above.\r\n\r\nMerging works best for objects like the `dependencies` object we just looked at.\r\nBut corridor can also merge arrays.\r\n\r\n### rich path names\r\n\r\nIn the last section we saw a rudimentary example of how to create nested data structures.\r\nThe range of supported names is quite rich.\r\n\r\nThese are best explained by example.\r\nLet's say you wanted to add `authors` to your package.json form, with a separate input for each author.\r\n\r\nThe HTML for that might look like this:\r\n\r\n```html\r\n<fieldset>\r\n  <label>\r\n    first author:\r\n    <input type=\"text\" name=\"authors[]\" value=\"your name\" />\r\n  </label>\r\n  <label>\r\n    second author:\r\n    <input type=\"text\" name=\"authors[]\" />\r\n  </label>\r\n  <label>\r\n    third author:\r\n    <input type=\"text\" name=\"authors[]\" />\r\n  </label>\r\n</fieldset>\r\n```\r\n\r\nThe name attribute for each author input is `authors[]`.\r\nThe trailing square brackets means that the input value should contribute to an array.\r\n\r\nRunning corridor on the above would give you JSON like this:\r\n\r\n```js\r\n{\r\n  authors: [\r\n    \"your name\"\r\n  ]\r\n}\r\n```\r\n\r\nNotice that there's only one element in this array.\r\nBy default, corridor makes an intelligent decision about wether to include empty values in the extracted data.\r\nSee the API documentation for how exactly it decides.\r\n\r\nYou can override the decision algorithm by specifying a `data-empty` attribute.\r\nIf you set empty to `include`, then the element's value will be included even if it's empty.\r\nIf you set empty to `omit`, then it'll be left out of the data representation if empty.\r\n\r\nJust like with the `dependencies.foo` case from last section, here we could split up the parts of the name between the fieldset and the inputs.\r\nE.g.\r\n\r\n```html\r\n<fieldset name=\"authors\">\r\n  <label>\r\n    first author:\r\n    <input type=\"text\" name=\"[]\" value=\"your name\" />\r\n```\r\n\r\nYou can mix and match dot delimited paths and square brackets to create even richer structures.\r\n\r\n```html\r\n<input type=\"text\" name=\"stock.ticker[]symbols\" value=\"BCOV AMZN\" data-type=\"list\" />\r\n```\r\n\r\nProduces this:\r\n\r\n```js\r\n\"stock\": {\r\n  \"ticker\": [\r\n    {\r\n      \"symbols\": [\r\n        \"BCOV\",\r\n        \"AMZN\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nWhitespace around key names is stripped, but whitespace inside them is preserved.\r\nFor example `name=\" foo bar \"` would produce an object with a `foo bar` property.\r\n\r\n### merging arrays\r\n\r\nMerging arrays can be tricky, but in most cases corridor will make a good choice.\r\n\r\nIn the last section, we looked at an example where the `authors` array contains normal string values.\r\nBut let's look at what happens when the values are more complex.\r\n\r\nConsider this HTML:\r\n\r\n```html\r\n<table data-name=\"company.employees[]\">\r\n  <tr>\r\n    <td><input type=\"text\" name=\"name\" value=\"Bob\" /></td>\r\n    <td><input type=\"text\" name=\"email\" value=\"bob@company.com\" /></td>\r\n  </tr>\r\n  <tr>\r\n    <td><input type=\"text\" name=\"name\" value=\"Alice\" /></td>\r\n    <td><input type=\"text\" name=\"email\" value=\"alice@company.com\" /></td>\r\n  </tr>\r\n</table>\r\n```\r\n\r\nFor this, `corridor()` produces the following:\r\n\r\n```js\r\n{\r\n  \"company\": {\r\n    \"employees\": [{\r\n      \"name\": \"Bob\",\r\n      \"email\": \"bob@company.com\"\r\n    },{\r\n      \"name\": \"Alice\",\r\n      \"email\": \"alice@company.com\"\r\n    }]\r\n  }\r\n}\r\n```\r\n\r\nThe reason this works is that corridor checks each field under an arry to see if it can be safely merged into the last one.\r\nSo when it finds Bob's `email`, it knows that it can safely add this key to the preceding Bob object without destroying data.\r\n\r\nBut when it gets to Alice's `name`, it sees that it couldn't safely add the value.\r\nIf it set the last object's `name` to Alice, then the `name` of Bob would be lost.\r\nSo it creates a new element and sets its `name` instead.\r\n\r\nFor more information on array merging, and how you can control it, see the API documentation.\r\n\r\n### toggling sections\r\n\r\nYou can mark sections of your UI as being toggleable using the `role` option.\r\n\r\nFor example, say you wanted a checkbox to control whether `keywords` were going to be included in the output.\r\nThe HTML for that might look like this:\r\n\r\n```html\r\n<fieldset data-role=\"toggleable\">\r\n  <p>\r\n    <label>\r\n      <input type=\"checkbox\" data-role=\"toggle\" checked/>\r\n      include keywords?\r\n    </label>\r\n  </p>\r\n  <p>\r\n    <label>\r\n      keywords (list format):\r\n      <textarea name=\"keywords\" data-type=\"list\"></textarea>\r\n    </label>\r\n  </p>\r\n</fieldset>\r\n```\r\n\r\nAdding the `toggleable` role to the `<fieldset>` signals to corridor that this section can be turned on and off.\r\nThe checkbox with the role `toggle` controls it.\r\n\r\nYou can nest toggleable sections inside each other.\r\nIn each case, the toggle that controls the toggleable container is the nearest child.\r\n\r\n### inserting data\r\n\r\nSo far, this tutorial has focused on explaining how data flows from HTML to JSON.\r\nBut corridor is great at sending data the other way as well.\r\n\r\nTo insert data back into the DOM, call the corridor function with a root element and a data structure object.\r\n\r\n```js\r\ncorridor(document.body, {\r\n  name: \"foo\",\r\n  keywords: [\"bar\", \"baz\"]\r\n});\r\n```\r\n\r\ncorridor uses the same `name` and `data-*` attributes to determine where data values should be inserted.\r\n\r\n### expanding to fit\r\n\r\nWhen you send data from JSON into HTML, there's a chance that there won't be enough room.\r\nThis is especilly true when working with arrays.\r\n\r\nConsider this input JSON:\r\n\r\n```js\r\n{\r\n  \"company\": {\r\n    \"employees\": [{\r\n      \"name\": \"Bob\",\r\n      \"email\": \"bob@company.com\"\r\n    },{\r\n      \"name\": \"Alice\",\r\n      \"email\": \"alice@company.com\"\r\n    }]\r\n  }\r\n}\r\n```\r\n\r\nAnd this HTML:\r\n\r\n```html\r\n<table>\r\n  <tr data-name=\"company.employees[]\">\r\n    <td><input type=\"text\" name=\"name\" /></td>\r\n    <td><input type=\"text\" name=\"email\" /></td>\r\n  </tr>\r\n</table>\r\n```\r\n\r\nIf you ran corridor in insert mode in this scenario, Alice would be lost since there's only one row for `company.employees`.\r\n\r\nFortunately, corridor can expand the DOM for you to make room for the extra elements.\r\nIf you set `data-expand` to `auto` on a named element, corridor will duplicate it to make room for data that otherwise wouldn't fit.\r\n\r\nHere's the same example again, with the `data-expand` attribute set:\r\n\r\n```html\r\n<table>\r\n  <tr data-name=\"company.employees[]\" data-expand=\"auto\">\r\n    <td><input type=\"text\" name=\"name\" /></td>\r\n    <td><input type=\"text\" name=\"email\" /></td>\r\n  </tr>\r\n</table>\r\n```\r\n\r\nAfter calling `corridor(table, data)`, the HTML in the page will look like this:\r\n\r\n```html\r\n<table>\r\n  <tr data-name=\"company.employees[]\" data-expand=\"auto\">\r\n    <td><input type=\"text\" name=\"name\" value=\"Bob\" /></td>\r\n    <td><input type=\"text\" name=\"email\" value=\"bob@company.com\" /></td>\r\n  </tr>\r\n  <tr data-name=\"company.employees[]\" data-expand=\"auto\">\r\n    <td><input type=\"text\" name=\"name\" value=\"Alice\" /></td>\r\n    <td><input type=\"text\" name=\"email\" value=\"alice@company.com\" /></td>\r\n  </tr>\r\n</table>\r\n```\r\n\r\nSince the expand feature is more intrusive in its side-effects in the DOM, you must enable it explicitly either by setting the `data-enabled` option, or in the options argument to the `corridor()` function.\r\n\r\n## corridor API\r\n\r\nThe corridor API consists of two major parts: the `corridor()` function itself, and the information in the HTML it uses to make decisions about how to operate.\r\n\r\n### corridor() function\r\n\r\nThe corridor function takes three parameters, all optional:\r\n\r\n```\r\ncorridor([root], [data], [opts])\r\n```\r\n\r\nThe parameters are:\r\n\r\n * `root` — The starting DOM element to search for named fields (defaults to `document`).\r\n * `data` — The plain JSON data object whose values are to be inserted.\r\n * `opts` — Additional options to inform how corridor makes decisions.\r\n\r\nThe presence of the second parameter, `data`, tells corridor whether it should extract data from the DOM or insert data into it.\r\n\r\n#### extracting data\r\n\r\nTo extract data from the DOM, call `corridor()` without the second argument, or set it to null.\r\n\r\nExamples:\r\n\r\n```js\r\ncorridor();\r\ncorridor(root);\r\ncorridor(root, null, opts);\r\ncorridor(null, null, opts);\r\n```\r\n\r\nIn _extract mode_, corridor will:\r\n\r\n * start at the `root` element,\r\n * find all named fields,\r\n * extract their values, and\r\n * return the plain JSON data object that results.\r\n\r\nThis is completely safe.\r\nNo side-effects are produced as a result of this operation, just data extraction.\r\n\r\n#### inserting data\r\n\r\nTo insert data into the DOM, call `corridor()` with an object as the second argument.\r\n\r\nExamples:\r\n\r\n```js\r\ncorridor(null, data);\r\ncorridor(root, data);\r\ncorridor(null, data, opts);\r\ncorridor(root, data, opts);\r\n```\r\n\r\nIn _insert mode_, corridor will:\r\n\r\n * start at the `root` element,\r\n * find all named fields,\r\n * set their values according to the `data` object (if a match can be found).\r\n\r\nThis will modify the values of discovered named fields where they differ from the data object representation.\r\n\r\n#### opts\r\n\r\nThe `opts` argument, when present, affects how corridor behaves in two ways.\r\nFirst, any values you specify will override the defaults for field value calculations.\r\n\r\nFor example, say you set the `type` property to `binary`:\r\n\r\n```js\r\ncorridor(null, null, {type:'binary'});\r\n```\r\n\r\nThis means that any fields without an explicit `type` declared will be coerced to binary values.\r\nFields with an explicit type (either as `data-type` or in `data-opts`) will still use their specified type though.\r\n\r\nSecondly, some options give hints to corridor's higher level behavior.\r\n\r\nFor example, the `enabledOnly` property controls whether corridor will operate on fields that are disabled by a `toggleable` parent.\r\nBy default `enabledOnly` is set to `true`, meaning only enabled fields are included.\r\nYou could set `enabledOnly` to `false` in the opts hash to tell corridor to ignore the effects of toggleables.\r\n\r\nAvailable options are:\r\n\r\n * `type` - the type of the field (_auto_, _string_, _boolean_, _number_, _list_, or _json_)\r\n * `empty` - whether to include the value in the output if the field is empty (_auto_, _include_, or _omit_)\r\n * `merge` - strategy to use when merging arrays (_auto_, _concat_, or _extend_)\r\n * `include` - whether a non-form element should be considered for insert/extract (_auto_, _always_, or _never_)\r\n * `extract` - strategy for pulling a value from a non-form element when extracting (_auto_, _value_, _text_, or _html_)\r\n * `insert` - strategy for putting a value into a non-form element when inserting (_auto_, _value_, _text_, or _html_)\r\n * `expand` - whether to expand the DOM to accomodate data that otherwise wouldn't fit (_never_, _auto_)\r\n * `role` - what role this element plays (_field_, _toggleable_, _toggle_, _expand_)\r\n * `enabledOnly` - only include enabled elements for consideration during insert/extract (_true_, _false_)\r\n\r\nNote that setting options via the `opts` param specifically affects the execution of the corridor function just once.\r\nPersistent options should be stored in the HTML.\r\n\r\n##### type option\r\n\r\nThe `type` option indicates the kind of field this is.\r\nThe type determines how corridor converts the string value of the form element into the data representation.\r\n\r\nThe recognized types are:\r\n\r\n * `auto` - automatically detect the correct type based on the value (default)\r\n * `string` - treat the value as a string\r\n * `boolean` - coerce this value to something true/false\r\n * `number` - parse this value as a number\r\n * `json` - leave this value as-is (will choke if it's not actually valid JSON)\r\n * `list` - parse this value as a list of values\r\n\r\nWhen automatically detecting the type, corridor uses the following algorithm:\r\n\r\n 1. attempt to parse the value as JSON, if successful, use this value\r\n  - _Note: this covers booleans and numbers as well as richer JSON structures._\r\n 2. otherwise treat the value as a string.\r\n\r\nThe list type will never be auto detected.\r\n\r\n##### empty option\r\n\r\nThe `empty` option indicates whether the value should be included in the output if its value is empty.\r\n\r\nChoices are:\r\n\r\n * `auto` - automatically detect the appropriate behavior based on the circumstances (default)\r\n * `include` - include the value in the output (default)\r\n * `omit` - do not add the field at all\r\n\r\nWhen empty is set to `auto`, corridor uses the following algorithm to between `include` and `omit`:\r\n\r\n * if the element has a `required` attribute, then choose `include`, otherwise,\r\n * if the element would contribute a value by appending to an array (ex: `name=\"authors[]\"`), choose `omit`, otherwise,\r\n * if the element is a checkbox, choose `omit`.\r\n\r\nIf none of these conditions are met, then choose `include`.\r\nWith this algorithim, most of the time an empty value will contribute to the output, except in cases where you probably expect it wouldn't.\r\n\r\n##### merge option\r\n\r\nThe `merge` option indicates which merging strategy corridor should use when merging two arrays.\r\n\r\nChoices are:\r\n\r\n * `auto` - intelligently choose whether to concatenate the arrays, or deep merge them (default)\r\n * `concat` - concatenate the arrays\r\n * `extend` - deep merge each pair of items\r\n\r\nWhen in `auto` mode, the algorithm for choosing whether to concatenate or merge two arrays should work as follows:\r\n\r\n * if the original array is empty, choose `concat`, otherwise,\r\n * if the length of the other array is greater than one, choose `concat` (this is a strange case), otherwise,\r\n * determine if the last element of the original array can be safely merged with the first element of the second array, if so, recursively merge them, otherwise,\r\n * choose `concat`.\r\n\r\nThe algorithm for deciding whether an object can be safely merged into a base object is as follows:\r\n\r\n * if either argument is a primitive (not an object or array), return false, otherwise,\r\n * if either argument is an array, return true (arrays can always be safely merged), otherwise,\r\n * recursively check the keys of the other object, if any can't be safely merged, return false,\r\n * return true.\r\n\r\nBoth _auto_ and _concat_ are safe operations.\r\nIn neither case is data lost.\r\nHowever, _extend_ is potentially (likely) unsafe—with this strategy, data is easily clobbered.\r\n\r\nIn all cases, if either the original or other object is not an array, there is no ambiguity to resolve.\r\nWhen at least one argument is not array-like, the merge will produce an object such that no information is lost (other than what is specifically overwritten by colliding keys).\r\n\r\nFor example, if the original object is an array (`[\"foo\"]`) and the other object is a non-array-like object (`{\"bar\":\"baz\"}`). then the outcome of the merge will be an object that keeps all data in tact (`{\"0\":\"foo\",\"bar\":\"baz\"}`).\r\n\r\n##### include option\r\n\r\nThe `include` option indicates whether a non-form element should be considered for insert/extract.\r\n\r\nChoices are:\r\n\r\n * `auto` - intelligently choose whether to include the element (default).\r\n * `always` - always include the element.\r\n * `never` - never include the element.\r\n\r\nWhen operating in _auto_ mode, corridor uses the following algorithm to decide whether a non-form element should be considered for insert/extract:\r\n\r\n * if the element is a form field (`input`, `textarea`, `select`), include it, otherwise,\r\n * if the element has no children with `name` or `data-name` attributes, include it, otherwise,\r\n * exclude it.\r\n\r\nOnly elements included by this algorithm will contribute to extracted output or receive inserted data.\r\n\r\n##### extract option\r\n\r\nThe `extract` option indicates how a value should be extracted from an element under consideration.\r\n\r\nChoices are:\r\n\r\n * `auto` - intelligently choose the best way to get a value (default).\r\n * `value` - get the element's form value (`value` attribute, except for `<select>` elements).\r\n * `text` - get the element's `textContent`.\r\n * `html` - get the element's `innerHTML`.\r\n\r\nWhen operating in _auto_ mode, corridor uses the following algorithm to decide how to extract a value:\r\n\r\n * if the element is a form field, use _value_ extraction, otherwise,\r\n * if the element has no child elements (only text), use _text_, otherwise,\r\n * if the element is a `<pre>` or `<code>` element, use _text_, otherwise,\r\n * use _html_.\r\n\r\nIf you set the extract option, it's much better to set it in the HTML specifically for a particular element.\r\nMost of the time, you'll want the _auto_ detection.\r\n\r\n##### insert option\r\n\r\nThe `insert` option indicates how a value should be inserted into an element under consideration.\r\n\r\nChoices are:\r\n\r\n * `auto` - intelligently choose the best way to insert the value (default).\r\n * `value` - set the element's form value (`value` attribute, except for `<select>` elements).\r\n * `text` - set the element's `textContent`.\r\n * `html` - set the element's `innerHTML`.\r\n\r\nWhen operating in _auto_ mode, corridor uses the following algorithm to decide how to insert a value:\r\n\r\n * if the element is a form field, use _value_ insertion, otherwise,\r\n * if the value appears to contain no HTML elements, use _text_, otherwise,\r\n * if the element is a `<pre>` or `<code>` element, use _text_, otherwise,\r\n * use _html_.\r\n\r\nIf you set the insert option, it's much better to set it in the HTML specifically for a particular element.\r\nMost of the time, you'll want the _auto_ detection.\r\n\r\n##### expand option\r\n\r\nThe `expand` option indicates whether corridor should make any attempt to expand the DOM to accomodate data that otherwise wouldn't fit.\r\n\r\nChoices are:\r\n\r\n * `never` - do not add any elements to the DOM (default).\r\n * `auto` - intelligently choose the best way to expand the DOM if necessary.\r\n\r\nWhen operating in _auto_ mode, corridor uses the following algorithm to decide how to expand the DOM:\r\n\r\n * identify candidates for expansion; these are elements which:\r\n  - have a `name` or `data-name` attribute,\r\n  - don't a `data-expand` value of `never`,\r\n  - have a name format that ends in `[]`,\r\n  - are not the children of such an element (the algorithm does _not_ recurse)\r\n * for each set of candidates:\r\n  - find the matching array from the source data,\r\n  - if there source data array and list of candidate fields have the same length, abort, otherwise,\r\n  - find the best target to clone, then,\r\n  - create N clone siblings of the target, appending each sequentially to the target's parent element, where N is the difference between the data array length and the length of the list of candidate elements.\r\n\r\nThe algorithm for finding a clone target for a set of candidate elements is:\r\n\r\n * start with the last element in the list of candidates (called `elem` here),\r\n * if that element is not a value'd form field:\r\n  - check for a child with `data-role` set to `expand`, if found, use it\r\n * if the element `elem` is a value'd form field:\r\n  - walk up the DOM looking for a parent with `data-role` set to `expand`, if found, use it, otherwise,\r\n  - walk up the DOM looking for either a `<li>` element or a `<tr>`, if found, use it\r\n * last resort, use the element `elem`\r\n\r\nKnown limitations:\r\n\r\n * Only the last candidate element is searched for a target to clone. It's not round-robin or based on the content of the data array.\r\n * The shortfall is calculated from the element which starts the process, not the target element.\r\n * The algorithm doesn't recurse, so nested expand elements will not be expanded.\r\n\r\nImproving on these limitations will require a major update to the code base to include an intermediate tree structure.\r\nThis tree structure would provide the rich information necessary to make more intelligent auto-expand decisions.\r\n\r\nSee [Issue #39](https://github.com/jimbojw/corridor/issues/39).\r\n\r\n##### toggle options\r\n\r\nOptions specific to the `toggleable`/`toggle` functionality are:\r\n\r\n * **role** — The role that this element plays in corridor operations. Choices are:\r\n  - _field_ - this element is a field whose value will contribute to extracted data (default)\r\n  - _toggleable_ - this element contains fields and may be toggled on or off\r\n  - _toggle_ - this element is a checkbox which toggles its nearest parent toggleable\r\n * **enabledOnly** — (boolean) When inserting/extracting, only operate on enabled fields (default: true).\r\n\r\n### HTML API\r\n\r\ncorridor inspects the Document Object Model (DOM) at runtime to figure out how to extract and insert data.\r\nSpecificially, it looks at these things:\r\n\r\n * the tag name,\r\n * the `name` (or `data-name`) attribute, and\r\n * the `data-*` (or `data-opts`) attributes.\r\n\r\nThe tag name influences whether corridor considers an element to have a value, and if so, how to retrieve it.\r\nFor instance, the way you extract a value from a `<textarea>` differs from how you extract a value from a `<select>` element.\r\n\r\nThe `name` attribute is by far the most important one to corridor.\r\nThe presence of a `name` attribute (or `data-name`) tells corridor that an element should be considered for data insertion/extraction.\r\nThe content of this attribute tells corridor exactly how to shuttle data between the element's value and the data representation.\r\n\r\nThe `data-*` attributes, when present, override the default options (see the _opts_ section above).\r\n\r\n#### name attribute\r\n\r\ncorridor uses the `name` attribute of an element to figure out how the _value_ of that element relates to the _data_ representation.\r\n\r\nYou can also use the `data-name` attribute instead.\r\ncorridor will actually check the `data-name` attribute first and use it if present, falling back to plain `name`.\r\nThis serves two purposes.\r\n\r\nFirst, strictly speaking, not all HTML5 elements allow the `name` attribute.\r\nBut HTML5 doel allow `data-` prefixed attributes on any element.\r\nIf you want to assign a name to a `p` or a `div` tag, for example, you should use `data-name`.\r\n\r\nSecondly, `data-name` supplies an alternative should your application require that the `name` field has a specific value.\r\nIf you need to keep `name` the same, but want corridor to address it by a different name value, you'd use `data-name`.\r\n\r\nThere are two formats you can use when specifying the name of an element: name format and field format.\r\n\r\n_Note: better names for \"name format\" and \"field format\" are forthcoming._\r\n\r\n#### name format\r\n\r\nThe name format is the more natural of the two formats.\r\nIn name format, the value resembles how you'd access a nested value inside an object in JavaScript.\r\n\r\nFor instance, say your JSON representation is this:\r\n\r\n```js\r\n{\r\n  \"book\": {\r\n    \"title\": \"The Art of War\"\r\n  }\r\n}\r\n```\r\n\r\nThen an input that maps to the `title` would have `name=\"book.title\"`:\r\n\r\n```html\r\n<input type=\"text\" name=\"book.title\" value=\"The Art of War\"/>\r\n```\r\n\r\nIn name format, use periods to separate keys.\r\nThey can nest to arbitrary depth, e.g. `{\"a\":{\"b\":{\"c\":\"foo\"}}}` maps to the element with `name=\"a.b.c\"`.\r\n\r\nYou can also use brackets to indicate a subkey (as opposed to using a period `.`).\r\nFor example, the following are all equivalent to `name=\"a.b.c\"`:\r\n\r\n * `name=\"[a][b][c]\"`\r\n * `name=\"a[b]c\"`\r\n * `name=\"a[b].c\"`\r\n * `name=\"a.b[c]\"`\r\n\r\nWhitespace is trimmed from the beginning and ending of keys, but not inside.\r\nSo `name=\"a b\"` is different from `name=\"a     b\"`, but all of the following are equivalent to `name=\"a.b.c\"`:\r\n\r\n * `name=\"[ a ][ b ][ c ]\"`\r\n * `name=\" a.b.c \"`\r\n * `name=\"a[b].   c\"`\r\n * `name=\"a.   b[c]\"`\r\n\r\nFinally, a pair of square brackets with nothing inside (`[]`) means that the value should contribute to an array.\r\nConsider this HTML:\r\n\r\n```html\r\n<input type=\"text\" name=\"book.authors[]\" value=\"Sunzi\"/>\r\n<input type=\"text\" name=\"book.authors[]\" value=\"Giles, Lionel\"/>\r\n```\r\n\r\nWith corridor, this would map to the following data representation:\r\n\r\n```js\r\n{\r\n  \"book\": {\r\n    \"authors\": [\r\n      \"Sunzi\",\r\n      \"Giles, Lionel\"\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nWhere you're appending to an array, you'll probably want the square brackets at the end, but this isn't strictly necessary.\r\nYour name attribute can have additional keys and bracket pairs after the first.\r\nHere are a few example names and the JSON data they'd map to:\r\n\r\n```js\r\n// <input name=\"authors[]name\" value=\"Sunzi\" />\r\n{\r\n  \"authors\": [\r\n    { \"name\": \"Sunzi\" }\r\n  ]\r\n}\r\n```\r\n\r\n```js\r\n// <input name=\"authors[][]\" value=\"Sunzi\" />\r\n{\r\n  \"authors\": [\r\n    [ \"Sunzi\" ]\r\n  ]\r\n}\r\n```\r\n\r\n```js\r\n// <input name=\"[][author]\" value=\"Sunzi\" />\r\n[ { \"author\": \"Sunzi\" } ]\r\n```\r\n\r\nIn most cases, using name format for your name attributes will give you what you need to correctly shuttle data between your JSON and your HTML.\r\nHowever, if your JSON is quite complex, you may need to use field format for some of your elements.\r\n\r\n#### field format\r\n\r\n_Note: field format will probably be removed in a future version of corridor_\r\n\r\nWhereas name format resembles how you'd _access_ an object in JavaScript, field format resembles how you describe an object in JavaScript—that is, JSON.\r\n\r\nWith field format, you specify how your data should appear as properly formatted JSON.\r\nExcept that you replace the value with the literal string `$$$`.\r\n\r\nFor example, consider the name format string `book.title`.\r\nThe field format version would be `{\"book\":{\"title\":$$$}}`.\r\nAny name format string can be converted to field format, but the opposite is not always true.\r\n\r\nHere are some name format strings and their field format equivalents:\r\n\r\n * `title` &rarr; `{\"title\":$$$}`\r\n * `book.title` &rarr; `{\"book\":{\"title\":$$$}}`\r\n * `authors[]` &rarr; `{\"authors\":[$$$]}`\r\n * `authors[]name` &rarr; `{\"authors\":[{\"name\":$$$}]}`\r\n * `[]` &rarr; `[$$$]`\r\n * `a.b.c` &rarr; `{\"a\":{\"b\":{\"c\":$$$}}}`\r\n\r\nYou should use the name format for your name attributes.\r\n\r\n#### data-opts attribute\r\n\r\nJust as `data-*` attributes override the default options, `data-opts` can also be used to override options.\r\nIf present, the `data-opts` attribute must contain valid JSON.\r\n\r\nFor example `data-type=\"list\"` is the same as `data-opts='{\"type\":\"list\"}'`.\r\nWhen both a `data-*` attribute and a `data-opts` key have the same name (like in this list example) corridor will use the value in `data-opts`.\r\nThis way, if your application already uses a `data-*` attribute that would conflict with corridor, you can use `data-opts` instead.\r\n\r\n## issues and feature requests\r\n\r\nIf you find any issues with corridor, or if you'd like to request a feature, please head over to the [issues page on github](https://github.com/jimbojw/corridor/issues).\r\n\r\nKeep in mind that the more specific you are, the more likely your issue or feature is to be addressed.\r\n\r\n## questions\r\n\r\nIf you have a question about how to use corridor, or if you're not sure if you're doing it right, go to [stackoverflow](http://stackoverflow.com/) and [ask a question](http://stackoverflow.com/questions/ask?tags=corridor).\r\nMake sure you add the `corridor` tag to your question.\r\n\r\n## developing corridor\r\n\r\nIf you're interested in developing corridor, great!\r\nStart by forking [corridor on github](https://github.com/jimbojw/corridor).\r\n\r\nOnce you've forked the project, clone it using `git clone`:\r\n\r\n```sh\r\n$ git clone git@github.com:<YOUR_USERNAME>/corridor.git\r\n```\r\n\r\nThe source code for corridor itself is in the `src/` directory.\r\n\r\ncorridor uses npm for packaging and deployment, so you'll need to install Node.js if you haven't already.\r\nOnce you have Node, you can pull in corridor's development dependencies:\r\n\r\n```sh\r\n$ npm install\r\n```\r\n\r\n### testing corridor\r\n\r\nThe corridor unit tests are in the `test/` directory.\r\ncorridor's unit tests are written to run in [nodeunit](https://npmjs.org/package/nodeunit) or with [QUnit](http://qunitjs.com/).\r\n\r\nAfter installing the npm dependencies, you can run the corridor unit tests from the command line like this:\r\n\r\n```sh\r\n$ npm test\r\n```\r\n\r\nTo run the unit tests in the browser, just open `test/index.html` and they'll run automatically.\r\n\r\n### submitting changes\r\n\r\nWhen you're satisfied with your changes, commit them and push them to your forked repository.\r\nThen open a pull request in github by hitting the big \"Pull Request\" button from the main project repo page.\r\n\r\n## License\r\n\r\nSee LICENSE\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}